import 'package:flutter/material.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/services.dart';
import 'package:move_young/services/haptics_service.dart';
import 'package:easy_localization/easy_localization.dart';
import 'package:move_young/models/game.dart';
import 'package:move_young/theme/_theme.dart';
import 'package:move_young/services/overpass_service.dart';
import 'package:move_young/services/weather_service.dart';
import 'package:move_young/services/games_service.dart';
import 'package:move_young/services/auth_service.dart';
import 'package:move_young/screens/main_scaffold.dart';
import 'package:move_young/services/friends_service.dart';
import 'package:move_young/services/cloud_games_service.dart';

class GameOrganizeScreen extends StatefulWidget {
  final Game? initialGame;
  const GameOrganizeScreen({super.key, this.initialGame});

  @override
  State<GameOrganizeScreen> createState() => _GameOrganizeScreenState();
}

class _GameOrganizeScreenState extends State<GameOrganizeScreen> {
  String? _selectedSport;
  DateTime? _selectedDate;
  String? _selectedTime;
  bool _isLoading = false;
  int _maxPlayers = 10;

  // Scroll controller for auto-scrolling
  final ScrollController _scrollController = ScrollController();
  final GlobalKey _createGameButtonKey = GlobalKey();

  // Fields data
  List<Map<String, dynamic>> _availableFields = [];
  Map<String, dynamic>? _selectedField;
  bool _isLoadingFields = false;
  bool _isPublic = true;

  // Weather data
  Map<String, String> _weatherData = {};
  // Booked times for selected field/date
  final Set<String> _bookedTimes = {};

  // Friend invites (selected friend UIDs)
  final Set<String> _selectedFriendUids = <String>{};
  // Locked invited users when editing an existing game
  final Set<String> _lockedInvitedUids = <String>{};

  // Original values for change detection when editing
  String? _originalSport;
  DateTime? _originalDate;
  String? _originalTime;
  int _originalMaxPlayers = 10;
  Map<String, dynamic>? _originalField;

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  // Auto-scroll to Create Game button
  void _scrollToCreateGameButton() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (_createGameButtonKey.currentContext != null) {
        Scrollable.ensureVisible(
          _createGameButtonKey.currentContext!,
          duration: const Duration(milliseconds: 500),
          curve: Curves.easeInOut,
          alignment: 0.1, // Show button near the top of the screen
        );
      }
    });
  }

  // Available sports with their icons
  final List<Map<String, dynamic>> _sports = [
    {
      'key': 'soccer',
      'icon': Icons.sports_soccer,
      'color': const Color(0xFF4CAF50),
    },
    {
      'key': 'basketball',
      'icon': Icons.sports_basketball,
      'color': const Color(0xFFFF9800),
    },
    {
      'key': 'tennis',
      'icon': Icons.sports_tennis,
      'color': const Color(0xFF8BC34A),
    },
    {
      'key': 'volleyball',
      'icon': Icons.sports_volleyball,
      'color': const Color(0xFFE91E63),
    },
    {
      'key': 'badminton',
      'icon': Icons.sports_handball,
      'color': const Color(0xFF9C27B0),
    },
    {
      'key': 'table_tennis',
      'icon': Icons.sports_tennis,
      'color': const Color(0xFF00BCD4),
    },
  ];

  // Generate list of dates for the next two weeks
  List<DateTime> get _availableDates {
    final today = DateTime.now();
    final dates = <DateTime>[];
    for (int i = 0; i < 14; i++) {
      dates.add(DateTime(today.year, today.month, today.day + i));
    }
    return dates;
  }

  List<String> get _availableTimes {
    final now = DateTime.now();
    final allTimes = [
      '09:00',
      '10:00',
      '11:00',
      '12:00',
      '13:00',
      '14:00',
      '15:00',
      '16:00',
      '17:00',
      '18:00',
      '19:00',
      '20:00',
      '21:00',
    ];

    // If no date is selected, return all times
    if (_selectedDate == null) return allTimes;

    // Check if selected date is today
    final today = DateTime(now.year, now.month, now.day);
    final selectedDate = DateTime(
      _selectedDate!.year,
      _selectedDate!.month,
      _selectedDate!.day,
    );

    if (selectedDate == today) {
      // Filter out past times for today
      final currentHour = now.hour;
      final currentMinute = now.minute;

      return allTimes.where((time) {
        final timeParts = time.split(':');
        final hour = int.parse(timeParts[0]);
        final minute = int.parse(timeParts[1]);

        // If the time is in the future, include it
        if (hour > currentHour ||
            (hour == currentHour && minute > currentMinute)) {
          return true;
        }
        return false;
      }).toList();
    }

    // For future dates, return all times
    return allTimes;
  }

  bool get _isFormComplete {
    return _selectedSport != null &&
        _selectedField != null &&
        _selectedDate != null &&
        _selectedTime != null;
  }

  // Check if any changes have been made to the game
  bool get _hasChanges {
    if (widget.initialGame == null) return false;

    // Check if new friends were invited (exclude locked ones)
    final newInvites = _selectedFriendUids
        .where((uid) => !_lockedInvitedUids.contains(uid))
        .toSet();

    return _selectedSport != _originalSport ||
        _selectedDate != _originalDate ||
        _selectedTime != _originalTime ||
        _maxPlayers != _originalMaxPlayers ||
        _selectedField?['name'] != _originalField?['name'] ||
        newInvites.isNotEmpty; // New check for friend invitations
  }

  // Load fields for the selected sport
  Future<void> _loadFields() async {
    if (_selectedSport == null) return;

    setState(() {
      _isLoadingFields = true;
      _availableFields = [];
    });

    try {
      // Only support soccer and basketball and keep 's-Hertogenbosch'
      final sportType =
          _selectedSport == 'basketball' ? 'basketball' : 'soccer';

      final rawFields = await OverpassService.fetchFields(
        areaName: "'s-Hertogenbosch",
        sportType: sportType,
      );

      // Normalize Overpass keys for UI consistency
      final fields = rawFields
          .map<Map<String, dynamic>>((f) {
            final name = f['name'] ?? 'Unnamed Field';
            final address = f['addr:street'] ?? f['address'];
            final lat = f['lat'] ?? f['latitude'];
            final lon = f['lon'] ?? f['longitude'];
            final lit = f['lit'] ?? f['lighting'];
            return {
              'name': name,
              'address': address,
              'latitude': lat,
              'longitude': lon,
              'surface': f['surface'],
              'lighting':
                  (lit == true) || (lit?.toString().toLowerCase() == 'yes'),
            };
          })
          .where((m) => m['latitude'] != null && m['longitude'] != null)
          .toList();

      setState(() {
        _availableFields = fields;
        _isLoadingFields = false;

        // If a field was preselected (e.g., editing a game), map it to the
        // corresponding instance from the freshly loaded list so identity
        // comparison (_selectedField == field) works for highlighting.
        if (_selectedField != null) {
          final String selName = (_selectedField?['name'] as String?) ?? '';
          final match = fields.firstWhere(
            (f) => (f['name'] as String?) == selName,
            orElse: () => {},
          );
          if (match.isNotEmpty) {
            _selectedField = match;
          }
        }
      });
    } catch (e) {
      setState(() {
        _availableFields = [];
        _isLoadingFields = false;
      });
    }
  }

  // Load weather data for the selected date
  Future<void> _loadWeather() async {
    if (_selectedDate == null) return;

    debugPrint(
        'üå§Ô∏è Loading weather for date: ${_selectedDate!.toIso8601String().split('T')[0]}');

    try {
      // Use a default location for 's-Hertogenbosch
      final weatherData = await WeatherService.fet